#pragma config(Sensor, S2,     LIGHT_R,        sensorLightActive)
#pragma config(Sensor, S3,     LIGHT_L,        sensorLightActive)
#pragma config(Sensor, S4,     SONAR,          sensorSONAR)
#pragma config(Motor,  motorB,          MOTOR_R,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          MOTOR_L,       tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma DebuggerWindows("debugStream")

/**
 * @file main.c
 * @author Julian van Doorn and Kiet van Osnabrugge
 * @brief Main loop for the robot
 */

/**
 * @brief Enumeration for the statu of the robot.
 */
enum STATUS_ENUM {
	FOLLOWING_LINE = 0,			/**< Robot is following the line */
	SLOWING_DOWN_JUNCTION = 1,	/**< Slowing down for approaching junction */
	WAITING_FOR_DIRECTION = 2	/**< Waiting for direction */
};

STATUS_ENUM status = FOLLOWING_LINE;

#include "sensors.h"
#include "nav.h"
#include "app.h"
#include "steering.h"

/**
 * @brief Main loop for the robot.
 * @todo Shrink the main loop and put large chunks of code in functions.
 */
task main() {
	white_value = get_light_left();
	init_nav_queue();
	init_app();

	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;

	enable_mode();

	nullify_derivative();

	while (1) {
		int power_left = get_power_left(stop_speed_multiplier);
		int power_right = get_power_right(stop_speed_multiplier);

		int sonar_value = get_sonar();

		if (status == FOLLOWING_LINE) {
			if (mode == BRABANT) {
				playSoundFile("! Attention.rso");
			} else if (mode == MANHATTAN) {
				playSoundFile("! Startup.rso");
			}
		}

		if ((power_left == 0 || power_right == 0) && abs(power_left - power_right) < 5 && force_stopped == false) {
			status = SLOWING_DOWN_JUNCTION;
		}

		if (status == SLOWING_DOWN_JUNCTION) {
			wait1Msec(150);

			float speed_multiplier = 1.0;

			while (speed_multiplier > 0) {
				power_left = get_power_left(speed_multiplier);
				power_right = get_power_right(speed_multiplier);
				motor[MOTOR_L] = power_left;
				motor[MOTOR_R] = power_right;
				speed_multiplier -= 0.02;
				wait1Msec(10);
			}

			status = WAITING_FOR_DIRECTION;
		}

		if (status == WAITING_FOR_DIRECTION) {
			status = WAITING_FOR_DIRECTION;

			power_left = 0;
			power_right = 0;
			DIRECTION dir = dequeue_direction();

			if (dir != NONE) {
				push_back_action(dir);
			}

			int p = get_power();

			switch(dir) {
				case LEFT:
					turn_left(p);
				break;
				case RIGHT:
					turn_right(p);
				break;
				case TURNABOUT:
					turn_around(power_left, power_right);
				break;
				case FORWARD:
					go_forward();
				break;
			}
		}

		if(sonar_value <= 10){
			turn_around(power_left, power_right);

			if (mode == MANHATTAN) {
				cur_car_dir = (CARDINAL_DIRECTION) (cur_car_dir + 2);
				next_node->enabled = false;

				empty_queue(&nav_queue);
				breadth_first_search(last_node, going_to_node);
			}
		}

   		motor[MOTOR_L] = power_left;
		motor[MOTOR_R] = power_right;

		if (stop_speed_multiplier == 0.0) {
			motor[MOTOR_L] = 0;
			motor[MOTOR_R] = 0;
			waitUntil(stop_speed_multiplier != 0.0);
		}
	}
}
