#pragma config(Sensor, S2,     LIGHT_R,        sensorLightActive)
#pragma config(Sensor, S3,     LIGHT_L,        sensorLightActive)
#pragma config(Sensor, S4,     SONAR,          sensorSONAR)
#pragma config(Motor,  motorB,          MOTOR_R,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          MOTOR_L,       tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma DebuggerWindows("debugStream")

#include "sensors.h"
#include "nav.h"
#include "app.h"
#include "steering.h"

task main() {
	init_nav_queue();
	init_app();

	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;

	while (1) {
		int power_left = get_power_left(stop_speed_multiplier);
		int power_right = get_power_right(stop_speed_multiplier);
		int sonar_value = get_sonar();

		writeDebugStreamLine("%d %d", power_left, power_right);

		if((power_left == 0 || power_right == 0) && abs(power_left - power_right) < 5) {
			DIRECTION dir = dequeue_direction();

			switch(dir) {
				case LEFT:
					steer_left(1000);
				break;
				case RIGHT:
					steer_right(1000);
				break;
				case TURNABOUT:
					turn_around(power_left, power_right);
				break;
				case FORWARD:
					motor[MOTOR_L] = POWER;
					motor[MOTOR_R] = POWER;
					waitUntil(get_light_left() > 50);
					waitUntil(get_light_right() > 50);
				break;
			}
		}

		if(sonar_value < 10){
			bool object = true;
			while (object == true){
				scan(20); //Robot checks if its passed the object, when it does: object == false
			}
			turn_right(600);
			go_straight(900);
			turn_left(600);
			go_straight(700);
			turn_left(600);
			sonar_value = get_sonar();
			if (sonar_value < 20){
					object = true;
			}
			while (object == true){
				scan(20); //Robot checks if its passed the object, when it does: object == false
			}
			turn_right(600);
			go_straight(700);
			turn_left(600);
			enqueue_direction(RIGHT);
		}

   	motor[MOTOR_L] = power_left;
		motor[MOTOR_R] = power_right;

		if (stop_speed_multiplier == 0.0) {
			motor[MOTOR_L] = 0;
			motor[MOTOR_R] = 0;
			waitUntil(stop_speed_multiplier != 0.0);
		}
	}
}
