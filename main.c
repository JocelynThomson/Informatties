#pragma config(Sensor, S2,     LIGHT_R,        sensorLightActive)
#pragma config(Sensor, S3,     LIGHT_L,        sensorLightActive)
#pragma config(Sensor, S4,     SONAR,          sensorSONAR)
#pragma config(Motor,  motorB,          MOTOR_R,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          MOTOR_L,       tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "sensors.h"
#include "nav.h"
#include "app.h"

task main() {
	init_nav_queue();
	init_app();

	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;

	while (1) {
		int power_left = get_power_left();
		int power_right = get_power_right();
		int sonar_value = get_sonar();

		if(power_left == 0 && power_right == 0) {
			DIRECTION dir = dequeue_direction();

			switch(dir) {
				case LEFT:
				//writeDebugStreamLine("TURNING LEFT");
				motor[MOTOR_L] = -25;
				motor[MOTOR_R] = 100;
				waitUntil(get_light_right() > 50);
				waitUntil(get_light_right() < 50);
				// ignore left sensor while turning left
				break;
				case RIGHT:
				motor[MOTOR_L] = 100;
				motor[MOTOR_R] = -25;
				waitUntil(get_light_left() > 50);
				waitUntil(get_light_left() < 50);
				//writeDebugStreamLine("TURNING RIGHT");
				// ignore right sensor while turning right
				break;
				case TURNABOUT:
				for (int i = (power_left + power_right) / 2; i > 0; i--) {
					motor[MOTOR_L] = i;
					motor[MOTOR_R] = i;
					wait1Msec(10);
				}

				for (int i = 0; i < 50; i++) {
					motor[MOTOR_L] = 20;
					motor[MOTOR_R] = -30;

					if (get_light_left() < 50 && i > 20) {
						motor[MOTOR_L] = 0;
						motor[MOTOR_R] = 0;
						break;
					}

					wait1Msec(100);
				}
				// ignore sensors until 135 degrees turned left
				break;
				default:
				motor[MOTOR_L] = POWER;
				motor[MOTOR_R] = POWER;
				waitUntil(get_light_left() > 50);
				waitUntil(get_light_right() > 50);
				// ignore sensors until white detected on both while driving forward
			}
		}

		if(sonar_value < 20){
			for (int i = (power_left + power_right) / 2; i > 0; i--) {
				motor[MOTOR_L] = i;
				motor[MOTOR_R] = i;
				wait1Msec(10);
			}

			for (int i = 0; i < 50; i++) {
				motor[MOTOR_L] = 20;
				motor[MOTOR_R] = -30;

				if (get_light_left() < 50 && i > 20) {
					motor[MOTOR_L] = 0;
					motor[MOTOR_R] = 0;
					break;
				}

				wait1Msec(100);
			}

			//powerLeft = 0;
			//powerRight = 0;
  	}

   	motor[MOTOR_L] = power_left;
		motor[MOTOR_R] = power_right;
	}
}
