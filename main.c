#pragma config(Sensor, S2,     LIGHT_R,        sensorLightActive)
#pragma config(Sensor, S3,     LIGHT_L,        sensorLightActive)
#pragma config(Sensor, S4,     SONAR,          sensorSONAR)
#pragma config(Motor,  motorB,          MOTOR_R,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          MOTOR_L,       tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma DebuggerWindows("debugStream")

/**
 * @file main.c
 * @author Julian van Doorn and Kiet van Osnabrugge
 * @brief Main loop for the robot
 */

enum STATUS_ENUM {
	FOLLOWING_LINE = 0,
	SLOWING_DOWN_JUNCTION = 1,
	SCANNING_JUNCTION = 2,
	WAITING_FOR_DIRECTION = 3
};

STATUS_ENUM status = FOLLOWING_LINE;

#include "sensors.h"
#include "nav.h"
#include "app.h"
#include "steering.h"

/**
 * @brief Converts the status enum to string and prints it immediately.
 */
void print_status() {
	switch (status) {
		case FOLLOWING_LINE:
			writeDebugStreamLine("FOLLOWING_LINE");
		break;
		case SLOWING_DOWN_JUNCTION:
			writeDebugStreamLine("SLOWING_DOWN_JUNCTION");
		break;
		case SCANNING_JUNCTION:
			writeDebugStreamLine("SCANNING_JUNCTION");
		break;
		case WAITING_FOR_DIRECTION:
			writeDebugStreamLine("WAITING_FOR_DIRECTION");
		break;
	}
}

void calibrate() {
	int black = 64;
	int white = 0;

	for (int i = 0; i < 100; i++) {
		motor[MOTOR_L] = -20;
		motor[MOTOR_R] = 20;
		int lv = get_light_left();

		if (lv > white) {
			white = lv;
		}
		wait1Msec(10);
	}
}

/**
 * @brief Main loop for the robot.
 * @todo Shrink the main loop and put large chunks of code in functions.
 */

task findPath() {
//	breadth_first_search(&nodes[0], &nodes[24]);
}

task main() {
	white_value = get_light_left();
	init_nav_queue();
	init_app();

	startTask(findPath);

	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;

	enable_mode();

	nullify_derivative();

	while (1) {
		int power_left = get_power_left(stop_speed_multiplier);
		int power_right = get_power_right(stop_speed_multiplier);

		//writeDebugStreamLine("%d %d", power_left, power_right);

		int sonar_value = get_sonar();

		if (status == FOLLOWING_LINE) {
			if (mode == BRABANT) {
				//playSoundFile("! Attention.rso");
			} else if (mode == MANHATTAN) {
				//playSoundFile("! Startup.rso");
			}
		}

		if ((power_left == 0 || power_right == 0) && abs(power_left - power_right) < 5 && force_stopped == false) {
			status = SLOWING_DOWN_JUNCTION;
		}

		if (status == SLOWING_DOWN_JUNCTION) {
			wait1Msec(150);

			float speed_multiplier = 1.0;

			while (speed_multiplier > 0) {
				power_left = get_power_left(speed_multiplier);
				power_right = get_power_right(speed_multiplier);
				motor[MOTOR_L] = power_left;
				motor[MOTOR_R] = power_right;
				speed_multiplier -= 0.02;
				wait1Msec(10);
			}

			//int p = get_power();

			//for (int i = p; i > 0; i--) {
			//	motor[MOTOR_L] = i;
			//	motor[MOTOR_R] = i;
			//	wait1Msec(7);
			//}

			status = WAITING_FOR_DIRECTION;
		}

		if (status == WAITING_FOR_DIRECTION) {
			status = WAITING_FOR_DIRECTION;

			power_left = 0;
			power_right = 0;
			DIRECTION dir = dequeue_direction();

			if (dir != NONE) {
				push_back_action(dir);
			}

			int p = get_power();

			switch(dir) {
				case LEFT:
					//steer_left(1000);
					//status = FOLLOWING_LINE;

					motor[MOTOR_L] = -p;
					motor[MOTOR_R] = p;

					waitUntil(get_light_left() < white_value - 5);

					motor[MOTOR_L] = -p;
					motor[MOTOR_R] = p;

					waitUntil(get_light_left() > white_value - 5);
					wait1Msec(50);

					motor[MOTOR_L] = -p;
					motor[MOTOR_R] = p;

					nullify_derivative();
					status = FOLLOWING_LINE;
				break;
				case RIGHT:
					//steer_right(1000);
					//status = FOLLOWING_LINE;

					motor[MOTOR_L] = p;
					motor[MOTOR_R] = -p;

					waitUntil(get_light_right() < white_value - 5);

					motor[MOTOR_L] = p;
					motor[MOTOR_R] = -p;

					waitUntil(get_light_right() > white_value - 5);
					wait1Msec(50);

					motor[MOTOR_L] = p;
					motor[MOTOR_R] = -p;

					nullify_derivative();
					status = FOLLOWING_LINE;
				break;
				case TURNABOUT:
					turn_around(power_left, power_right);
					status = FOLLOWING_LINE;
				break;
				case FORWARD:
					//int origin_l = get_light_left();
					//int origin_r = get_light_right();
					////int p = get_power();
					//motor[MOTOR_L] = p;
					//motor[MOTOR_R] = p;
					//waitUntil(get_light_left() > origin_l && get_light_right() > origin_r);
					status = FOLLOWING_LINE;
				break;
			}
		}

		//writeDebugStreamLine("%d", sonar_value);

		if(sonar_value <= 10){
			turn_around(power_left, power_right);

			if (mode == MANHATTAN) {
				cur_car_dir += 2;
				next_node->enabled = false;

				writeDebugStreamLine("node: %d enabled: %d", next_node->index, next_node->enabled);

				empty_queue(&nav_queue);
				breadth_first_search(last_node, going_to_node);
			}
		}

   	motor[MOTOR_L] = power_left;
		motor[MOTOR_R] = power_right;

		if (stop_speed_multiplier == 0.0) {
			motor[MOTOR_L] = 0;
			motor[MOTOR_R] = 0;
			waitUntil(stop_speed_multiplier != 0.0);
		}
	}
}
