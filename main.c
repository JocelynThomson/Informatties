#pragma config(Sensor, S2,     LIGHT_R,        sensorLightActive)
#pragma config(Sensor, S3,     LIGHT_L,        sensorLightActive)
#pragma config(Sensor, S4,     SONAR,          sensorSONAR)
#pragma config(Motor,  motorB,          MOTOR_R,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          MOTOR_L,       tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma DebuggerWindows("debugStream")

enum STATUS_ENUM {
	FOLLOWING_LINE = 0,
	SLOWING_DOWN_JUNCTION = 1,
	SCANNING_JUNCTION = 2,
	WAITING_FOR_DIRECTION = 3
};

STATUS_ENUM status = FOLLOWING_LINE;

#include "sensors_pid_enhanced.h"
#include "nav.h"
#include "app.h"
#include "steering.h"

void print_status() {
	switch (status) {
		case FOLLOWING_LINE:
			writeDebugStreamLine("FOLLOWING_LINE");
		break;
		case SLOWING_DOWN_JUNCTION:
			writeDebugStreamLine("SLOWING_DOWN_JUNCTION");
		break;
		case WAITING_FOR_DIRECTION:
			writeDebugStreamLine("WAITING_FOR_DIRECTION");
		break;
	}
}

task main() {
	init_nav_queue();
	init_app();

	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;

	while (1) {
		print_status();

		int power_left = get_power_left(stop_speed_multiplier);
		int power_right = get_power_right(stop_speed_multiplier);
		int sonar_value = get_sonar();

		show_queue(nav_queue);

		if ((power_left == 0 || power_right == 0) && abs(power_left - power_right) < 5) {
			status = SLOWING_DOWN_JUNCTION;
		}

		if (status == SLOWING_DOWN_JUNCTION) {
			int p = get_power();

			for (int i = p; i > 0; i--) {
				motor[MOTOR_L] = i;
				motor[MOTOR_R] = i;
				wait1Msec(40);
			}

			status = WAITING_FOR_DIRECTION;
		}

		if (status == WAITING_FOR_DIRECTION) {
			status = WAITING_FOR_DIRECTION;

			power_left = 0;
			power_right = 0;
			DIRECTION dir = dequeue_direction();

			switch(dir) {
				case LEFT:
					steer_left(1000);
					status = FOLLOWING_LINE;

					//int p = get_power();

					//motor[MOTOR_L] = -p;
					//motor[MOTOR_R] = p;

					//waitUntil(get_light_left() < white_value - 5);

					//motor[MOTOR_L] = -p;
					//motor[MOTOR_R] = p;

					//waitUntil(get_light_left() > white_value - 5);

					//motor[MOTOR_L] = -p;
					//motor[MOTOR_R] = p;

					//undo_derivative();
				break;
				case RIGHT:
					steer_right(1000);
					status = FOLLOWING_LINE;
				break;
				case TURNABOUT:
					turn_around(power_left, power_right);
					status = FOLLOWING_LINE;
				break;
				case FORWARD:
					int origin_l = get_light_left();
					int origin_r = get_light_right();
					//int p = get_power();
					motor[MOTOR_L] = p;
					motor[MOTOR_R] = p;
					waitUntil(get_light_left() > origin_l && get_light_right() > origin_r);
					status = FOLLOWING_LINE;
				break;
			}
		}

		if(sonar_value < 10){
			bool object = true;
			while (object == true){
				turn_right(600);
				go_straight(400);
				turn_left(600);
				sonar_value = get_sonar();
				if (sonar_value > 20){
					object = false;
			  }
			}
			turn_right(600);
			go_straight(900);
			turn_left(600);
			go_straight(700);
			turn_left(600);
			sonar_value = get_sonar();
			if (sonar_value < 20){
					object = true;
			}
			while (object == true){
				turn_right(600);
				go_straight(700);
				turn_left(600);
				sonar_value = get_sonar();
				if (sonar_value > 20){
					object = false;
			  }
			}
			turn_right(600);
			go_straight(700);
			turn_left(600);
			enqueue_direction(RIGHT);
			//go_straight(400);

			//if (get_light_left() < 50 || get_light_right() < 50){
			//	enqueue_direction(RIGHT);
			//}
		}

   	motor[MOTOR_L] = power_left;
		motor[MOTOR_R] = power_right;

		if (stop_speed_multiplier == 0.0) {
			motor[MOTOR_L] = 0;
			motor[MOTOR_R] = 0;
			waitUntil(stop_speed_multiplier != 0.0);
		}
	}
}
